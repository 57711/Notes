import{_ as e,o as i,c as o,e as n}from"./app-7D7ZZLlA.js";const c="/Notes/images/STUN-TRUN.png",r="/Notes/images/webrtc-diagram.png",a="/Notes/images/webrtc1.png",t="/Notes/images/webrtc2.png",d={},s=n('<h1 id="webrtc" tabindex="-1"><a class="header-anchor" href="#webrtc" aria-hidden="true">#</a> WebRTC</h1><p>基于P2P， UDP</p><p>三个服务器：</p><ul><li>room服务器，房间管理，</li><li>信令服务器，</li><li>流媒体中转服务器</li></ul><h2 id="信令服务器" tabindex="-1"><a class="header-anchor" href="#信令服务器" aria-hidden="true">#</a> 信令服务器</h2><p>发起端发送 SDP（<strong>媒体信息</strong>）和candidate（ <strong>网络信息</strong>），到信令服务器，</p><p>信令服务器 转发到接收端</p><p><strong>媒体信息</strong>：Session Description Protocol，是数据格式，包含编码器、分辨率之类的信息</p><p><strong>网络信息</strong>：ip</p><p>信令服务器可以用websocket</p><h2 id="stun" tabindex="-1"><a class="header-anchor" href="#stun" aria-hidden="true">#</a> STUN</h2><p>Session Traversal Utilities for NAT,NAT会话穿越应用程序，可以让NAT后的客户端找到公网地址</p><h2 id="turn" tabindex="-1"><a class="header-anchor" href="#turn" aria-hidden="true">#</a> TURN</h2><p>Traversal Using Relays around NAT,是STUN/RFC5389的一个拓展，服务器中转，当打洞失败时，可以作为中继</p><h2 id="ice" tabindex="-1"><a class="header-anchor" href="#ice" aria-hidden="true">#</a> ICE</h2><p>ICE是一组穿透方法而不是协议，它融合了STUN和TURN，ICE使得两个NAT后设备通信更加便捷，ICE使用STUN进行打洞，若失败，则使用TURN进行中转。</p><p><img src="'+c+'" alt="STUN and TRUN"></p><h2 id="webrtc-api" tabindex="-1"><a class="header-anchor" href="#webrtc-api" aria-hidden="true">#</a> WebRTC api</h2><p>mediaStream， RTCPeerConnection</p><h2 id="连接过程" tabindex="-1"><a class="header-anchor" href="#连接过程" aria-hidden="true">#</a> 连接过程</h2><p>媒体协商 + 网络协商</p><p>双方都创建PeerConnection， 一方发送offer SDP， 另一方应答answer SDP，最后双方再交换ICE candidate。</p><ol><li>发送端请求本地流，<code>MediaDevices.getUserMedia</code></li><li>发送端实例 <code>RTCPeerConnection</code> ，加入本地媒体流 <code>RTCPeerConnection.addTrack()</code> (Since addStream is deprecating)</li><li><strong>发送端创建offer</strong>， <code>RTCPeeConnection.createOffer()</code>，拿到sdp</li><li>发送端配置sdp， <code>RTCPeerConnection.setLocalDescription()</code>，本地端</li><li>之后发送端请求STUN 服务器创建 ice candidates， <code>onIceCandidate</code>事件</li><li>发送端 请求信令服务器 传输 offer 到 接收端.</li><li>接收端 接收 offer，调用 <code>RTCPeerConnection.setR emoteDescription()</code> 记录远端的description</li><li>接收端 获取本地流, 将每个media tracks 挂到peer connection，<code>RTCPeerConnection.addTrack()</code></li><li><strong>接收端创建answer</strong>，<code>RTCPeerConnection.createAnswer()</code></li><li>接收端 设置本地端description，调用 <code>RTCPeerConnection.setLocalDescription()</code>. 接收端有两端端信息</li><li>接收端 通过信令服务器发送answer 到发送端.</li><li>发送端 收到answer</li><li>发送端 调用 <code>RTCPeerConnection.setRemoteDescription()</code> 设置远端的 description， 发送端也知道两端信息</li></ol><p>网络协商</p><ol><li>发送端请求STUN服务器，监听<code>onIceCandidate</code>事件获取candidate，</li><li>通过信令服务器发送candidate 到接收端</li><li>接收端 <code>peerConnection.addIceCandidate</code> 到接收端的ice层</li><li>接收端同样请求STUN，发送给发送端</li><li>candidate成功连接<code>peerConnection.onTrack</code>收到对方流，开始p2p</li><li>无法打通，借助TURN中转</li></ol><p>结束通话</p><ol><li>结束track， <code>videoElem.srcObject.getTracks().forEach(...stop())</code></li><li>清除peerConnection的事件回调</li><li>关闭连接<code>peerConnection.close()</code></li></ol><p><img src="'+r+'" alt="连接过程"></p><p><img src="'+a+'" alt="webrtc1"><img src="'+t+'" alt="webrtc2"></p>',29),l=[s];function p(h,T){return i(),o("div",null,l)}const g=e(d,[["render",p],["__file","WebRTC.html.vue"]]);export{g as default};

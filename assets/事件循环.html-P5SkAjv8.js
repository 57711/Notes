import{_ as e,o as l,c as i,e as a}from"./app-7D7ZZLlA.js";const o="/Notes/images/Life-of-a-frame.jpg",t="/Notes/images/v2-5980966fe9c651d8868c69cd85bdfabe_r.jpg",s={},r=a('<h1 id="event-loop" tabindex="-1"><a class="header-anchor" href="#event-loop" aria-hidden="true">#</a> Event Loop</h1><ul><li>js 是单线程，所以需要实现异步, 非阻塞试 io。</li><li>event loop 就是异步回调的实现原理</li><li>将异步任务交给其他线程处理， 处理完将回调函数包装成任务放到任务队列等待主线程执行</li></ul><p>node 中由 LIBUV c++库提供 event loop,和非阻塞式 io</p><h2 id="event-loop-流程" tabindex="-1"><a class="header-anchor" href="#event-loop-流程" aria-hidden="true">#</a> event loop 流程</h2><ol><li>同步代码，一行一行放在 CallStack 执行</li><li>遇到异步，会先“记录”下，等待时机（定时、网络请求等）</li><li>时机到了，就移动到 Callback Queue</li><li>如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作</li><li>轮询查找 Callback Queue，如有则移动到 Call Stack 执行</li><li>然后继续轮询查找（永动机一样）</li></ol><h2 id="本质" tabindex="-1"><a class="header-anchor" href="#本质" aria-hidden="true">#</a> 本质</h2><ul><li><p>微任务是 ES6 语法规定的（promise、async/await）</p><p>ES 语法标准之内，JS 引擎来统一处理。即，不用浏览器有任何干预，即可一次性处理完，更快更及时。</p><p>产生微任务直接进入微任务队列</p></li><li><p>宏任务是由浏览器 W3C 规定的（setTimeout/setInterval、Ajax、DOM）</p><p>JS 引擎不处理，浏览器（或 nodejs）干预处理。</p><p>产生宏任务先进入第三方模块 ，谁先完成谁在进入队列， 队列按顺序执行</p></li></ul><p>浏览器中：</p><ul><li>macro task 宏任务：MessageChannel、postMessage、setImmediate 和 setTimeout，setInterval。</li><li>micro task 微任务：Promise.then，queueMicrotask()和 MutationObsever。</li></ul><p>requestAnimationFrame 在重绘重排之前执行，所以回调如果是长任务会阻塞渲染。浏览器会根据刷新了计算下一次渲染的时间来判断是否执行 rAF。</p><p>同步代码也归为宏任务<code>&lt;script&gt;</code>。中的代码也看作宏任务</p><h2 id="浏览器中-event-loop" tabindex="-1"><a class="header-anchor" href="#浏览器中-event-loop" aria-hidden="true">#</a> 浏览器中 event loop</h2><ol><li>执行 JS 同步代码（遇到异步函数，分别放在 macroTaskQueue 和 microTaskQueue ）</li><li>DOM 对象结构更新（此时还没有在页面显示，但可以获取 DOM 内容了）</li><li>执行微任务 microTaskQueue 函数（异步中还可能嵌套异步...）</li><li>渲染 DOM 到页面</li><li>执行宏任务 macroTaskQueue 函数（异步中还可能嵌套异步...）</li><li>...</li></ol><p><img src="'+o+'" alt="Life of a frame"><img src="'+t+'" alt="frame of browser"></p><h2 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> Node</h2><h3 id="队列优先级" tabindex="-1"><a class="header-anchor" href="#队列优先级" aria-hidden="true">#</a> 队列优先级</h3><ol><li><p>process.nextTick —— 微任务，但优先级最高</p></li><li><p>promise 和 async/await —— 微任务</p></li><li><p>setTimeout setInterval —— 宏任务</p></li><li><p>I/O 文件、网络 —— 宏任务</p></li><li><p>Socket 连接：连接 mysql —— 宏任务</p></li><li><p>setImmediate —— 宏任务</p></li></ol><p>不同于浏览器， nodejs 中宏任务有优先级， 浏览器中先来后到</p><ul><li>timers(计时器) - 执行 setTimeout 以及 setInterval 的回调</li><li>I/O callbacks - 处理网络、流、TCP 的错误回调</li><li>idle, prepare --- 闲置阶段 - node 内部使用</li><li>poll(轮循) - 执行 poll 中的 I/O 队列，检查定时器是否到时间</li><li>check(检查) - 存放 setImmediate 回调</li><li>close callbacks - 关闭回调，例如 socket.on(&#39;close&#39;)</li></ul>',19),c=[r];function n(p,d){return l(),i("div",null,c)}const u=e(s,[["render",n],["__file","事件循环.html.vue"]]);export{u as default};

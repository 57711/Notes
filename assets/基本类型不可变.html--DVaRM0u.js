import{_ as a,o as n,c as e,e as s}from"./app-7D7ZZLlA.js";const t={},i=s(`<h1 id="基本类型不可变" tabindex="-1"><a class="header-anchor" href="#基本类型不可变" aria-hidden="true">#</a> 基本类型不可变</h1><h2 id="js数据类型" tabindex="-1"><a class="header-anchor" href="#js数据类型" aria-hidden="true">#</a> Js数据类型</h2><h3 id="js是动态类型" tabindex="-1"><a class="header-anchor" href="#js是动态类型" aria-hidden="true">#</a> js是动态类型</h3><p>变量和类型没有关联</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// foo 现在是一个数值</span>
foo <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span> <span class="token comment">// foo 现在是一个字符串</span>
foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// foo 现在是一个布尔值</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="js是弱类型" tabindex="-1"><a class="header-anchor" href="#js是弱类型" aria-hidden="true">#</a> js是弱类型</h3><p>允许隐式类型转换，对于 symbol 和 BigInt，JavaScript 有意禁止了某些隐式类型转换。</p><h3 id="原始值" tabindex="-1"><a class="header-anchor" href="#原始值" aria-hidden="true">#</a> 原始值</h3><ul><li><p>string JavaScript 字符串是<strong>不可变</strong>的。这意味着一旦字符串被创建，就不可能修改它。</p><p>实际上字符串本身是一种经过由语言封装后的基础类型（通过系统自带的String构造函数new出来的），底层还是一个对象，不是简单数据类型。这个对象自从创建之后其内容就不能发生改变，所以字符串不变。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;J&quot;</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">isFrozon</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true es6</span>
Object<span class="token punctuation">.</span><span class="token function">isSealed</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true es6</span>
Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false es6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>number</p></li><li><p>boolean</p></li><li><p>bigint BigInt 并不是严格等于有着相同数学值的 Number，而是宽松的相等。</p><p>BigInt 值并不总是更精确的，也不总是比 number 精确，因为 BigInt 不能表示小数，但可以更精确地表示大整数。这两种类型都不能相互替代。如果 BigInt 值在算术表达式中与常规 number 值混合，或者它们相互隐式转换，则抛出 TypeError。</p></li><li><p>symbol Symbol 是<strong>唯一</strong>并且<strong>不可变</strong>的原始值并且可以用来作为对象属性的键（如下）。</p></li><li><p>undefined</p></li><li><p>null 从概念上讲，<code>undefined</code> 表示值的缺失，<code>null</code> 表示对象的缺失（这也可以说明 <code>typeof null === &quot;object&quot;</code> 的原因）。当某些东西没有值时，该语言通常默认为 <code>undefined</code>.</p><p><code>null</code> 是一个关键字，但是 <code>undefined</code> 是一个普通的标识符，恰好是一个全局属性。在实践中，这两个差异很小，因为 <code>undefined</code> 不应该被重新定义或者遮蔽。</p><p>undefined 在全局作用域是只读的，但在局部作用域中可以改变undefined的值。用<code>viod 0</code> 代替<code>undefined</code>.</p></li></ul><h3 id="引用" tabindex="-1"><a class="header-anchor" href="#引用" aria-hidden="true">#</a> 引用</h3><ul><li>object 在 JavaScript 中，对象是唯一可变的值。事实上，函数也是具有额外可调用能力的对象。</li></ul><h4 id="数据属性" tabindex="-1"><a class="header-anchor" href="#数据属性" aria-hidden="true">#</a> 数据属性</h4><ul><li>value</li><li>writable</li><li>enumerable</li><li>configurable</li></ul><h4 id="访问器属性" tabindex="-1"><a class="header-anchor" href="#访问器属性" aria-hidden="true">#</a> 访问器属性</h4><ul><li>get</li><li>set</li><li>enumerable</li><li>configurable</li></ul><h4 id="数组-类型化数组" tabindex="-1"><a class="header-anchor" href="#数组-类型化数组" aria-hidden="true">#</a> 数组/类型化数组</h4><ul><li>array</li><li>Int8Array、Float32Array...</li></ul><h4 id="set-map-weakmap-weakset" tabindex="-1"><a class="header-anchor" href="#set-map-weakmap-weakset" aria-hidden="true">#</a> Set, Map, WeakMap, WeakSet</h4><p>这些数据结构把对象的引用当作键。Set 和 WeakSet 表示唯一值的集合，而 Map 和 WeakMap 表示键值相关联的集合。</p><p>它们的原生实现（包括 WeakMap）可以达到近似对数到常数时间的查找性能。</p><p><code>WeakMap</code> 和 <code>WeakSet</code> 只允许将可垃圾回收的值作为键，这些键要么是对象，要么是未注册的 symbol，即使键仍在集合中，也可能被收集。它们专门用于优化内存使用。</p><h2 id="强制类型转换" tabindex="-1"><a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a> 强制类型转换</h2><p>对象将依次调用它的 <code>[@@toPrimitive]()</code>（将 default 作为 hint 值）、<code>valueOf()</code> 和 <code>toString()</code> 方法，将其转换为原始值。</p><p>原始值转换先调用 <code>valueOf()</code> 再调用 <code>toString()</code> 方法，这与数字类型强制转换的行为相似，但与字符串类型强制转换不同。</p><p>有三种不同的路径可以将对象转换为原始值：</p><ul><li>原始值强制转换：<code>[@@toPrimitive](&quot;default&quot;) → valueOf() → toString()</code></li><li>数字类型强制转换、number 类型强制转换、BigInt 类型强制转换：<code>[@@toPrimitive](&quot;number&quot;) → valueOf() → toString()</code></li><li>字符串类型强制转换：<code>[@@toPrimitive](&quot;string&quot;) → toString() → valueOf()</code></li></ul>`,26),o=[i];function c(l,p){return n(),e("div",null,o)}const d=a(t,[["render",c],["__file","基本类型不可变.html.vue"]]);export{d as default};

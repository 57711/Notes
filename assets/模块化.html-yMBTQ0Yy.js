import{_ as n,o as s,c as a,e}from"./app-7D7ZZLlA.js";const t={},p=e(`<h1 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h1><h2 id="为什么模块化" tabindex="-1"><a class="header-anchor" href="#为什么模块化" aria-hidden="true">#</a> 为什么模块化</h2><p>通过函数作用域，把<strong>变量和函数</strong>进行<strong>隔离</strong></p><ol><li>项目多个文件好管理</li><li>作用域隔离（变量可被访问的范围）</li><li>全局变量污染（不同模块变量冲突）</li><li>模块引入依赖顺序</li></ol><p>模块化需要解决 1. 变量管理， 2. 模块相互通信（module.exports）</p><h2 id="commonjs" tabindex="-1"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> commonjs</h2><p>特点：</p><ul><li>每个文件就是一个模块</li><li>每个模块有单独作用域， 同 esm</li><li>通过 module.exports 导出成员</li><li>通过 require 载入模块</li><li>同步加载 =&gt; 在启动时加载， 运行时直接使用， 加载并执行，依赖加载顺序</li><li>加载过的模块缓存，循环依赖</li></ul><p>cjs 运行时才能确定依赖关系,requre 可以放在判断中。</p><div class="custom-container tip"><p class="custom-container-title">同步加载的意思是</p><p>commonjs 执行， 碰到 require 就执行 require 的文件， 执行完毕后才回到主文件。 加载的本质就是拿到代码模块并执行， 输出返回值</p></div><h3 id="循环引用" tabindex="-1"><a class="header-anchor" href="#循环引用" aria-hidden="true">#</a> 循环引用</h3><p>有循环引用的话， 因为有 cache， 所以模块都只执行一次。</p><h3 id="webpack-实现代码" tabindex="-1"><a class="header-anchor" href="#webpack-实现代码" aria-hidden="true">#</a> webpack 实现代码</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">modules</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> moduleCache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token parameter">moduleId</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>moduleCache<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> moduleCache<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token punctuation">(</span>moduleCache<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">exports</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    modules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span> require<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里执行可以用eval包裹</span>

    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./src/A.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token string-property property">&#39;./src/A.js&#39;</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./src/B.js&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
      foo<span class="token punctuation">,</span>
      bar<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">&#39;./src/B.js&#39;</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> require</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="esmodule" tabindex="-1"><a class="header-anchor" href="#esmodule" aria-hidden="true">#</a> ESModule</h2><p>浏览器需要异步加载。esm 依赖关系是明确的，可以在编译时确定</p><p>特点：</p><ol><li>自动采用严格模式， 全局范围不能使用 this，</li><li>每个 esmodule 运行在独立私有作用域中， 同 cjs</li><li>import 在最顶层声明， 且不能导入动态的 路径， 动态导入用 import()</li><li>导出有具名成员，和 default 成员，导出的为引用</li><li>export {func1, func2} 不是导出对象， 而是语法 import { func1, func2 } 也不是解构 export default {func1, func2} 导出的是对象， default 后面的是值</li></ol><h3 id="html-中" tabindex="-1"><a class="header-anchor" href="#html-中" aria-hidden="true">#</a> html 中</h3><ol><li>html 中使用 <code>&lt;script type=“module”&gt;</code>, <code>&lt;script nomodule&gt;</code>可以判断兼容</li><li>每个 esmodule 通过 cors 请求，需要同源（没有 type=“module” 就没有同源限制）</li><li>会延迟执行，相当于 defer</li></ol><h3 id="node-中" tabindex="-1"><a class="header-anchor" href="#node-中" aria-hidden="true">#</a> node 中</h3><ol><li>文件为 mjs</li><li>Package.json 中 type 设为“module”</li><li>node —input-type=module</li></ol><h3 id="循环引用-1" tabindex="-1"><a class="header-anchor" href="#循环引用-1" aria-hidden="true">#</a> 循环引用</h3><p><code>cannot access uninitialized variable.</code></p><p>会记录模块的加载状态，加载还没有 export 的模块是 undefined，已经加载过的就不会再次加载</p><h2 id="cjs-esm-区别" tabindex="-1"><a class="header-anchor" href="#cjs-esm-区别" aria-hidden="true">#</a> cjs esm 区别</h2><ol><li>require 动态导入。esm 静态导入，且在 top-level，可以做 tree-shaking</li><li>require 同步加载文件（node），esm 异步加载（浏览器网络请求）</li><li>commonjs 导出一个新对象 <code>module.exports</code>, esm 导出具名或默认元素，为引用</li><li>原生 esm <code>from</code> 后的路径不能省略， commonjs 可以， index.js/ .js.。 相对路径./ 也不能省略， 否则为第三方模块</li></ol>`,27),o=[p];function c(i,l){return s(),a("div",null,o)}const r=n(t,[["render",c],["__file","模块化.html.vue"]]);export{r as default};

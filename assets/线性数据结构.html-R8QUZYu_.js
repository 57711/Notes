import{_,r as h,o as g,c as f,a as n,d as l,b as a,w as s,e as m}from"./app-7D7ZZLlA.js";const y="/Notes/images/array-1.png",x="/Notes/images/array-2.png",k="/Notes/images/截屏2023-12-16-15.58.37.png",w={},b=n("h1",{id:"线性数据结构",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#线性数据结构","aria-hidden":"true"},"#"),l(" 线性数据结构")],-1),M=n("h2",{id:"array-数组",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#array-数组","aria-hidden":"true"},"#"),l(" Array 数组")],-1),O=n("p",null,"内存中连续的一段区域",-1),N=n("strong",null,"查找",-1),v={class:"katex"},K={class:"katex-mathml"},L=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span>',1),E=n("strong",null,"插入",-1),B={class:"katex"},A={class:"katex-mathml"},C=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span>',1),V=n("strong",null,"删除",-1),z={class:"katex"},I={class:"katex-mathml"},q=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span>',1),F=n("h2",{id:"linked-list-链表",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#linked-list-链表","aria-hidden":"true"},"#"),l(" linked list 链表")],-1),S=n("p",null,"单链表 双链表: 有前驱，后继，可以双向走",-1),T=n("p",null,[n("strong",null,"优点")],-1),j={class:"katex"},D={class:"katex-mathml"},G=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span>',1),H=n("li",null,"不知道一共有多少个元素",-1),J=n("p",null,[n("strong",null,"缺点")],-1),P={class:"katex"},Q={class:"katex-mathml"},R=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span>',1),U=n("p",null,"应用",-1),W=n("ul",null,[n("li",null,"区块链 链表/二叉树")],-1),X=n("p",null,[n("img",{src:y,alt:"block chain"})],-1),Y=n("h3",{id:"例子",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#例子","aria-hidden":"true"},"#"),l(" 例子")],-1),Z={href:"https://leetcode.cn/problems/reverse-linked-list/",target:"_blank",rel:"noopener noreferrer"},$={href:"https://leetcode.cn/problems/swap-nodes-in-pairs/description/",target:"_blank",rel:"noopener noreferrer"},aa={href:"https://leetcode.cn/problems/linked-list-cycle/",target:"_blank",rel:"noopener noreferrer"},sa=n("h2",{id:"栈-队列",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#栈-队列","aria-hidden":"true"},"#"),l(" 栈 / 队列")],-1),la=n("p",null,"可以用数组或链表实现，或双链表",-1),na=n("h3",{id:"例子-1",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#例子-1","aria-hidden":"true"},"#"),l(" 例子")],-1),ta={href:"https://leetcode.cn/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},ea={href:"https://leetcode.cn/problems/implement-queue-using-stacks/",target:"_blank",rel:"noopener noreferrer"},oa={href:"https://www.bigocheatsheet.com/",target:"_blank",rel:"noopener noreferrer"},ra=n("img",{src:x,alt:"事件复杂度"},null,-1),pa=n("h2",{id:"优先队列",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#优先队列","aria-hidden":"true"},"#"),l(" 优先队列")],-1),ca=n("p",null,"正常入，按照优先级出。 优先级大小，次数，或者某个属性",-1),ma=n("h3",{id:"实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#实现","aria-hidden":"true"},"#"),l(" 实现")],-1),ia={href:"/algorithem/%E6%95%B0-%E5%9B%BE.html#%E5%A0%86-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91",target:"_blank",rel:"noopener noreferrer"},ha=n("ul",null,[n("li",null,[l("小顶二叉堆，每个父节点元素"),n("strong",null,"小于"),l("左右子节点元素，越小越排前面，最小元素永远在堆顶")]),n("li",null,[l("大顶堆， 每个父节点元素"),n("strong",null,"大于"),l("左右子节点元素，最大元素永远在堆顶，")])],-1),da=n("li",null,[n("p",null,"二叉搜索树")],-1),ua=n("h3",{id:"例子-2",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#例子-2","aria-hidden":"true"},"#"),l(" 例子")],-1),_a=n("ul",null,[n("li",null,[n("strong",null,"队列弹出最小元素"),l(" （小顶堆）")])],-1),ga=n("p",null,"弹出堆顶，再更新剩下的元素成堆",-1),fa={class:"katex"},ya={class:"katex-mathml"},xa=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span>',1),ka=n("ul",null,[n("li",null,[n("strong",null,"队列插入")])],-1),wa={class:"katex"},ba={class:"katex-mathml"},Ma=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span>',1),Oa=n("ul",null,[n("li",null,[n("strong",null,"堆排序")])],-1),Na={class:"katex"},va={class:"katex-mathml"},Ka=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span>',1),La={href:"https://leetcode.cn/problems/kth-largest-element-in-a-stream/",target:"_blank",rel:"noopener noreferrer"},Ea=n("strong",null,"思路1",-1),Ba={class:"katex"},Aa={class:"katex-mathml"},Ca=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span>',1),Va=n("strong",null,"思路2",-1),za={class:"katex"},Ia={class:"katex-mathml"},qa=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">))</span></span></span>',1),Fa={class:"katex"},Sa={class:"katex-mathml"},Ta=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span>',1),ja={href:"https://leetcode.cn/problems/sliding-window-maximum/",target:"_blank",rel:"noopener noreferrer"},Da=n("strong",null,"思路1",-1),Ga={class:"katex"},Ha={class:"katex-mathml"},Ja=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span>',1),Pa=n("strong",null,"思路2",-1),Qa={class:"katex"},Ra={class:"katex-mathml"},Ua=m('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span>',1),Wa=n("h3",{id:"堆的时间复杂度",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#堆的时间复杂度","aria-hidden":"true"},"#"),l(" 堆的时间复杂度")],-1),Xa=n("p",null,[n("img",{src:k,alt:"堆的时间复杂度"})],-1);function Ya(Za,$a){const t=h("mi"),e=h("mo"),d=h("mn"),o=h("mrow"),r=h("annotation"),p=h("semantics"),c=h("math"),i=h("ExternalLinkIcon"),u=h("msub");return g(),f("div",null,[b,M,O,n("p",null,[N,l(),n("span",v,[n("span",K,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(d,null,{default:s(()=>[l("1")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(1)")]),_:1})]),_:1})]),_:1})]),L])]),n("p",null,[E,l(" 后面的元素需要向后挪动 "),n("span",B,[n("span",A,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("n")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(n)")]),_:1})]),_:1})]),_:1})]),C])]),n("p",null,[V,l(" 后面的元素也需要向前移动 "),n("span",z,[n("span",I,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("n")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(n)")]),_:1})]),_:1})]),_:1})]),q])]),F,S,T,n("ul",null,[n("li",null,[l("改善插入和删除操作 "),n("span",j,[n("span",D,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(d,null,{default:s(()=>[l("1")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(1)")]),_:1})]),_:1})]),_:1})]),G])]),H]),J,n("ul",null,[n("li",null,[l("查找需要 "),n("span",P,[n("span",Q,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("n")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(n)")]),_:1})]),_:1})]),_:1})]),R])])]),U,W,X,Y,n("ul",null,[n("li",null,[n("a",Z,[l("反转链表"),a(i)])]),n("li",null,[n("a",$,[l("两辆交换节点"),a(i)])]),n("li",null,[n("a",aa,[l("判断有环"),a(i)])])]),sa,la,na,n("ul",null,[n("li",null,[n("a",ta,[l("判断括号问题"),a(i)]),l(" 用栈或者字符串replace")]),n("li",null,[n("a",ea,[l("用栈实现队列"),a(i)]),l(" 一个输入栈， 一个输出栈")])]),n("p",null,[n("a",oa,[ra,a(i)])]),pa,ca,ma,n("ul",null,[n("li",null,[n("p",null,[l("堆（binary 二叉堆， binominal多项式堆， fibonacci斐波那契堆） 详见"),n("a",ia,[l("完全二叉树"),a(i)])]),ha]),da]),ua,_a,ga,n("p",null,[l("最后一个元素放到堆顶，再下滤 "),n("span",fa,[n("span",ya,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(logN)")]),_:1})]),_:1})]),_:1})]),xa])]),ka,n("p",null,[l("插入到尾部，上滤 "),n("span",wa,[n("span",ba,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(logN)")]),_:1})]),_:1})]),_:1})]),Ma])]),Oa,n("p",null,[l("大根堆，根元素与最后元素交换，下滤，重复过程，得到从小到大排序 "),n("span",Na,[n("span",va,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(NlogN)")]),_:1})]),_:1})]),_:1})]),Ka])]),n("ul",null,[n("li",null,[n("a",La,[l("实时判断第K大元素"),a(i)])])]),n("p",null,[Ea,l(": 记录前k大元素， 并且排序，每次进来元素都需要排序 "),n("span",Ba,[n("span",Aa,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,null,{default:s(()=>[l("∗")]),_:1}),a(t,null,{default:s(()=>[l("K")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("K")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(N*KlogK)")]),_:1})]),_:1})]),_:1})]),Ca])]),n("p",null,[Va,l(": 不用排序， 利用优先队列， 前K大元素放到小顶堆中， 堆顶为第k大的元素(堆中最小值)， 每次进来元素调整堆， 把原来堆中小的剔除， 返回堆顶元素 "),n("span",za,[n("span",Ia,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,null,{default:s(()=>[l("∗")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(d,null,{default:s(()=>[l("1")]),_:1}),a(e,null,{default:s(()=>[l("+")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(u,null,{default:s(()=>[a(t,null,{default:s(()=>[l("g")]),_:1}),a(d,null,{default:s(()=>[l("2")]),_:1})]),_:1}),a(t,null,{default:s(()=>[l("K")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(N*(1 + log_2 K))")]),_:1})]),_:1})]),_:1})]),qa]),l(" => "),n("span",Fa,[n("span",Sa,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("K")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(NlogK)")]),_:1})]),_:1})]),_:1})]),Ta])]),n("ul",null,[n("li",null,[n("a",ja,[l("滑动窗口最大值"),a(i)])])]),n("p",null,[Da,l(": 堆。窗口中k个元素放入大顶堆中， 每次滑动移除或添加新的元素到堆中，堆顶为K中的最大值 "),n("span",Ga,[n("span",Ha,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(t,null,{default:s(()=>[l("l")]),_:1}),a(t,null,{default:s(()=>[l("o")]),_:1}),a(t,null,{default:s(()=>[l("g")]),_:1}),a(t,null,{default:s(()=>[l("K")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(NlogK)")]),_:1})]),_:1})]),_:1})]),Ja])]),n("p",null,[Pa,l(": 双端队列， 前后都可以进出。每次入元素就维护队列， 保持最左边的为队列中最大值， 从窗口的右侧开始遍历，比入数小的都pop出去。维护的复杂度为1。 适用于K大小恒定，且只关心最大值， 不需要维护第K大的值。 "),n("span",Qa,[n("span",Ra,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:s(()=>[a(p,null,{default:s(()=>[a(o,null,{default:s(()=>[a(t,null,{default:s(()=>[l("O")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l("(")]),_:1}),a(t,null,{default:s(()=>[l("N")]),_:1}),a(e,{stretchy:"false"},{default:s(()=>[l(")")]),_:1})]),_:1}),a(r,{encoding:"application/x-tex"},{default:s(()=>[l("O(N)")]),_:1})]),_:1})]),_:1})]),Ua])]),Wa,Xa])}const ss=_(w,[["render",Ya],["__file","线性数据结构.html.vue"]]);export{ss as default};

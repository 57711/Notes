import{_ as i,r,o,c as p,a as e,d as n,b as s,e as t}from"./app-7D7ZZLlA.js";const l="/Notes/images/TCP三次握手.webp",c="/Notes/images/TCP连接断开.webp",d="/Notes/images/三次握手的原因.jpg",u="/Notes/images/Handshake(TLS1.3).webp",h="/Notes/images/Handshake(Diffie-Hellman).webp",v="/Notes/images/TLS1.2.png",m="/Notes/images/Browser-csrf.webp",k={},b=t('<h1 id="网络" tabindex="-1"><a class="header-anchor" href="#网络" aria-hidden="true">#</a> 网络</h1><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h2><h3 id="连接过程" tabindex="-1"><a class="header-anchor" href="#连接过程" aria-hidden="true">#</a> 连接过程</h3><p><img src="'+l+'" alt="TCP三次握手"></p><p><img src="'+c+'" alt="TCP连接断开"></p><p>LISTEN：等待从任何远端 TCP 和端口的连接请求。</p><p>SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。</p><p>SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。</p><p>ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。</p><p>FIN_WAIT_1：等待远端 TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。</p><p>FIN_WAIT_2：等待远端 TCP 的连接终止请求。</p><p>CLOSE_WAIT：等待本地用户的连接终止请求。</p><p>CLOSING：等待远端 TCP 的连接终止请求确认。</p><p>LAST_ACK：等待先前发送给远端 TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）</p><p>TIME_WAIT：等待足够的时间过去以确保远端 TCP 接收到它的连接终止请求的确认。</p><p>TIME_WAIT 两个存在的理由： 1.可靠的实现 tcp 全双工连接的终止； 2.允许老的重复分节在网络中消逝。</p><p>CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）</p><h3 id="三次握手的原因" tabindex="-1"><a class="header-anchor" href="#三次握手的原因" aria-hidden="true">#</a> 三次握手的原因</h3><ol><li>（首要原因）防止旧的重复连接初始化造成混乱。旧请求先到 如果是两次握手客户端没办法告诉服务端是不是旧的</li><li>同步双方的初始序列号</li><li>避免资源浪费</li></ol><p><img src="'+d+'" alt="三次握手的原因"></p><h2 id="tls" tabindex="-1"><a class="header-anchor" href="#tls" aria-hidden="true">#</a> TLS</h2><h3 id="tls1-3" tabindex="-1"><a class="header-anchor" href="#tls1-3" aria-hidden="true">#</a> TLS1.3</h3><p><img src="'+u+`" alt="TLS1.3"></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 原 DH 握手</span>
<span class="token operator">-</span><span class="token number">1.</span>浏览器向服务器发送 client_random，<span class="token constant">TLS</span> 版本和供筛选的加密套件列表。
<span class="token comment">// TLS1.3 优化</span>
<span class="token operator">+</span><span class="token number">1.</span>浏览器向服务器发送 client_params，client_random，<span class="token constant">TLS</span> 版本和供筛选的加密套件列表。
 <span class="token comment">// 原 DH 握手</span>
<span class="token operator">-</span><span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// TLS1.3 优化</span>
<span class="token operator">+</span><span class="token number">2.</span>服务器返回：server_random、server_params、<span class="token constant">TLS</span> 版本、确定的加密套件方法以及证书。
<span class="token operator">+</span>浏览器接收，先验证数字证书和签名。
<span class="token operator">+</span>现在双方都有 client_params、server_params，可以根据 <span class="token constant">ECDHE</span> 计算出 pre_random <span class="token function">了。非对称</span>
<span class="token punctuation">(</span>Elliptic Curve Diffie<span class="token operator">-</span>Hellman Ephemeral<span class="token punctuation">)</span>临时椭圆曲线迪菲<span class="token operator">-</span>赫尔曼交换
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="椭圆曲线离散对数-tls1-2" tabindex="-1"><a class="header-anchor" href="#椭圆曲线离散对数-tls1-2" aria-hidden="true">#</a> 椭圆曲线离散对数 TLS1.2</h3><p><img src="`+h+`" alt="TLS1.2"> ￼</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1.</span>浏览器向服务器发送随机数 client_random，<span class="token constant">TLS</span> 版本和供筛选的加密套件列表。
<span class="token comment">// RSA</span>
<span class="token operator">-</span><span class="token number">2.</span>服务器接收到，立即返回 server_random，确认好双方都支持的加密套件 <span class="token operator">-</span><span class="token function">以及数字证书</span> <span class="token punctuation">(</span>证书中附带公钥<span class="token punctuation">)</span>。
<span class="token comment">// DH</span>
<span class="token operator">+</span><span class="token number">2.</span>服务器接收到，立即返回 server_random，确认好双方都支持的加密套件
<span class="token operator">+</span><span class="token function">以及数字证书</span> <span class="token punctuation">(</span>证书中附带公钥<span class="token punctuation">)</span>。
<span class="token operator">+</span>同时服务器利用私钥将 client_random<span class="token punctuation">,</span>server_random，server_params 签名，
<span class="token operator">+</span>生成服务器签名。然后将签名和 server_params 也发送给客户端。
<span class="token operator">+</span>这里的 server_params 为 <span class="token constant">DH</span> 算法所需参数。
<span class="token comment">// RSA</span>
<span class="token operator">-</span><span class="token number">3.</span>浏览器接收，先验证数字证书。
<span class="token operator">-</span>若通过，接着使用加密套件的密钥协商算法 <span class="token constant">RSA</span> 算法 <span class="token operator">-</span>生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
<span class="token comment">// DH</span>
<span class="token operator">+</span><span class="token number">3.</span>浏览器接收，先验证数字证书和 _签名_。
 <span class="token operator">+</span>若通过，将 client_params 传递给服务器。
<span class="token operator">+</span>这里的 client_params 为 <span class="token constant">DH</span> 算法所需参数。

<span class="token operator">-</span><span class="token number">4.</span>服务器用私钥解密这个被加密后的 pre_random，参考 “非对称加密”。
 <span class="token operator">+</span><span class="token number">4.</span>现在客户端和服务器都有 client_params、server_params 两个参数，
<span class="token operator">+</span>因 <span class="token constant">ECDHE</span> 计算基于 “椭圆曲线离散对数”，通过这两个 <span class="token constant">DH</span> 参数就能计算出 pre_random。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+v+`" alt="TLS1.2"></p><p>￼</p><h2 id="tcp-udp-区别" tabindex="-1"><a class="header-anchor" href="#tcp-udp-区别" aria-hidden="true">#</a> TCP/ UDP 区别</h2><ul><li>Tcp 需要链接， 有重传机制， 点对点</li><li>UDP 效率高， 多对多</li></ul><h2 id="http-请求头" tabindex="-1"><a class="header-anchor" href="#http-请求头" aria-hidden="true">#</a> HTTP 请求头</h2><ul><li>Origin：协议+域名+端口，主要用于跨域。</li><li>Host：域名+端口，HTTP2 对应字段为 :authority，主要用于服务器区分服务。</li><li>Referer：去掉 fragment（锚点）和 userinfo（用户信息）的 url，用于确认请求的来源页面。 <ul><li>通过设置 noreferer, 来避免携带 referer<code>&lt;a href=&quot;&quot; rel=&quot;noreferer&quot;&gt;link&lt;/a&gt;</code></li></ul></li></ul><h3 id="host" tabindex="-1"><a class="header-anchor" href="#host" aria-hidden="true">#</a> host</h3><p>多个 host 指向同一个 ip，一个服务器 host 多个服务，此时仅仅通过 IP 无法访问到对应的服务，可通过 Host 来进行定位。</p><p>仅包括<strong>域名和端口号</strong>，如 test.pay.com:8090。</p><p>Host 是唯一客户端必须携带的请求头，如果缺失了该请求头则会返回 400 状态码。在 HTTP/2 以及 HTTP/3 中，以一个伪头 :authority 代替。</p><h3 id="origin-表明请求来源" tabindex="-1"><a class="header-anchor" href="#origin-表明请求来源" aria-hidden="true">#</a> origin 表明请求来源</h3><p>当前请求资源所在页面的<strong>协议，主机，端口</strong>，用来说明请求从哪里发起的，如<code>http://test.my.com:8081</code></p><p>这个参数一般只存在于 CORS 跨域请求中，服务端据此判断是否允许跨域,普通请求没有这个 header！ 如果有 Origin 参数，我们可以看到 response 有对应的 header：<code>Access-Control-Allow-Origin</code></p><p>从广义上讲，用户代理会在以下情况中添加 Origin 请求标头：</p><ul><li>跨源请求。</li><li>除 GET 和 HEAD 以外的同源请求（即它会被添加到同源的 POST、OPTIONS、PUT、PATCH 和 DELETE 请求中）。</li></ul><h3 id="referer" tabindex="-1"><a class="header-anchor" href="#referer" aria-hidden="true">#</a> referer</h3><p>当前请求页面的来源页面的<strong>完整路径</strong>：协议+域名+查询参数（注意不包含锚点信息）,即表示当前页面是通过此来源页面里的链接进入的，如<code>http://test.my.com/p/GHB2021081702-001/index.html?a=1&amp;b=2</code>，所有类型的请求都包含此 header。</p><p>服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。</p><p>在以下两种情况下，Referer 不会被发送：</p><ul><li>来源页面采用的协议为表示本地文件的 &quot;file&quot; 或者 &quot;data&quot; URI；</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）。</li></ul><p>nginx 对不同域名的配置</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>server {
    # 博客页面
    server_name  blog.fstars.wang;
    location / {
        proxy_pass   http://localhost:3000;
        proxy_cache
    }
}
server {
    # 图片等资源
    server_name  static.fstars.wang;
    location / {
        root   /www/static/;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="http-1-0-1-1-2" tabindex="-1"><a class="header-anchor" href="#http-1-0-1-1-2" aria-hidden="true">#</a> http 1.0/1.1/2</h2>`,50),f=e("li",null,"http1.0 建立一个 tcp 连接，进行一次 http 请求，然后会断开 tcp 连接。",-1),_=e("li",null,[n("http1.1, 有 keep-alive，默认不断开连接 "),e("ul",null,[e("li",null,"http1.1 请求一般一次进行一个 http 请求。"),e("li",null,"http1.1 的 pipeline 可以一次发送多个 http 请求，但是响应需要按顺序，有堆头阻塞。")])],-1),g={href:"/frontend/%E4%BC%98%E5%8C%96.html#http2",target:"_blank",rel:"noopener noreferrer"},x=e("li",null,"浏览器限制 tcp 连接数 6 个",-1),T=t(`<h2 id="状态码" tabindex="-1"><a class="header-anchor" href="#状态码" aria-hidden="true">#</a> 状态码</h2><h3 id="_3xx" tabindex="-1"><a class="header-anchor" href="#_3xx" aria-hidden="true">#</a> 3xx</h3><h4 id="_301-moved-permanently-永久" tabindex="-1"><a class="header-anchor" href="#_301-moved-permanently-永久" aria-hidden="true">#</a> 301 moved permanently 永久</h4><ul><li>不可预测重定向方法 一般转为 get 推荐响应 get/head</li><li>缓存</li><li>搜索引擎会抓取网址 B 的内容，同时将网址保存为 B 网址。</li></ul><h4 id="_302-found-临时" tabindex="-1"><a class="header-anchor" href="#_302-found-临时" aria-hidden="true">#</a> 302 found 临时</h4><ul><li>不可预测重定向方法 一般转为 get 推荐响应 get/head</li><li>不缓存</li><li>时搜索引擎会抓取 B 网址内容，但是会将网址保存为 A 的。</li><li>因为保存为 a 的， 会有网址劫持风险</li></ul><h4 id="_303-see-other" tabindex="-1"><a class="header-anchor" href="#_303-see-other" aria-hidden="true">#</a> 303 see other</h4><p>重定向方法改为 Get（put -&gt; get）</p><h4 id="_304-not-modified" tabindex="-1"><a class="header-anchor" href="#_304-not-modified" aria-hidden="true">#</a> 304 not modified</h4><p>缓存 协商缓存 etag/if-none-match. last-modified/if-modified-since</p><h4 id="_307-temporary-redirect" tabindex="-1"><a class="header-anchor" href="#_307-temporary-redirect" aria-hidden="true">#</a> 307 temporary redirect</h4><p>重用原始方法和消息主体</p><h4 id="_308-permanent-redirect" tabindex="-1"><a class="header-anchor" href="#_308-permanent-redirect" aria-hidden="true">#</a> 308 permanent redirect</h4><p>重用原始方法和消息主体</p><h3 id="_4xx" tabindex="-1"><a class="header-anchor" href="#_4xx" aria-hidden="true">#</a> 4xx</h3><h4 id="_401-unauthorized" tabindex="-1"><a class="header-anchor" href="#_401-unauthorized" aria-hidden="true">#</a> 401 unauthorized</h4><p>没有身份验证凭证</p><h4 id="_403-forbidden" tabindex="-1"><a class="header-anchor" href="#_403-forbidden" aria-hidden="true">#</a> 403 forbidden</h4><p>进入 403，即使重新验证也不会改变该状态</p><h4 id="_404-not-found" tabindex="-1"><a class="header-anchor" href="#_404-not-found" aria-hidden="true">#</a> 404 not found</h4><h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> websocket</h2><p>同时、双向、实时通信的技术，客户端通过 Http 协议请求，在握手阶段升级为 WebSocket 协议。基于 tcp。</p><h3 id="headers" tabindex="-1"><a class="header-anchor" href="#headers" aria-hidden="true">#</a> headers</h3><p>connection: upgrade, upgrade: websocket,</p><p>Websocket 通过 HTTP/1.1 协议的 101 状态码进行握手</p><p>请求</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET / HTTP/1.1
Host: localhost:8080
# 类似Host、Origin、Cookie等请求首部会照常发送
Origin: [url=http://127.0.0.1:3000]http://127.0.0.1:3000[/url]
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13 #websocket 版本
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
Sec-WebSocket-Protocol: chat, superchat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>响应</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传输使用数据帧，支持二进制，或文本</p><h2 id="sse-server-sent-events" tabindex="-1"><a class="header-anchor" href="#sse-server-sent-events" aria-hidden="true">#</a> SSE server-sent events</h2><p>服务器向客户端发送文本消息的技术，SSE 基于 HTTP 协议中的持久连接，具有由 W3C 标准化的网络协议和 EventSource 客户端 api。</p><p>缺点：</p><ol><li><p>它是单向的，只能由服务端发送给客户端</p></li><li><p>只发送文本消息；尽管可以使用 Base64 编码和 gzip 压缩来发送二进制消息，但效率很低。</p></li><li><p>许多浏览器允许打开数量非常有限的 SSE 连接（Chrome、Firefox 每个浏览器最多 6 个连接）</p></li><li><p>客户端发出 GET 请求，和 header，来订阅服务器事件</p></li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /sse HTTP/1.1
Accept: text/event-stream 表示可接收事件流类型
Cache-Control: no-cache 禁用任何的事件缓存
Connection: keep-alive 表示正在使用持久连接
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>服务器确认订阅</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HTTP/1.1 200
Content-Type: text/event-stream;charset=UTF-8 表示标准要求的事件的媒体类型和编码
Transfer-Encoding: chunked 表示服务器流式传输动态生成的内容，因此内容大小事先未知
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><code>EentSource</code> API</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> eventSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">&#39;/sse?event=type1&amp;event=type2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
eventSource<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;connection is established&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
eventSource<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;id: &#39;</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>lastEventId <span class="token operator">+</span> <span class="token string">&#39;, data: &#39;</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
eventSource<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
    <span class="token string">&#39;connection state: &#39;</span> <span class="token operator">+</span> eventSource<span class="token punctuation">.</span>readyState <span class="token operator">+</span> <span class="token string">&#39;, error: &#39;</span> <span class="token operator">+</span> event
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
eventSource<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
eventSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">&#39;/sse?event=type1&amp;event=type2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="安全" tabindex="-1"><a class="header-anchor" href="#安全" aria-hidden="true">#</a> 安全</h2><h3 id="csrf-跨站请求伪造" tabindex="-1"><a class="header-anchor" href="#csrf-跨站请求伪造" aria-hidden="true">#</a> csrf 跨站请求伪造</h3><p><img src="`+m+'" alt="csrf"></p><p>已登录用户访问攻击者网站，攻击网站向被攻击网站服务器发起恶意请求（利用浏览器会自动携带 cookie）。</p><p>在业界目前防御 CSRF 攻击主要有三种策略：</p><ol><li>验证 HTTP Referer / origin 字段；依赖于浏览器的实现</li><li>在请求地址中添加 token 并验证；</li><li>在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。</li><li>添加验证码 CAPTCHA</li><li>CORS，</li><li>cookie，set-cookie： SameSite</li></ol><h3 id="xss-跨站脚本攻击" tabindex="-1"><a class="header-anchor" href="#xss-跨站脚本攻击" aria-hidden="true">#</a> xss 跨站脚本攻击</h3><p>攻击者脚本   嵌入   被攻击网站，获取用户 cookie 等隐私信息。</p><ul><li>存储型：注入恶意的代码到服务器， 通过 input 提交代码</li><li>反射型：点击恶意链接， 注入脚本进入被攻击者的网站， 服务端不存储恶意代码</li><li>劫持：传输过程中劫持， 修改 html dom</li></ul><p>防御策略：</p><ol><li>对输入脚本进行过滤或转码， 白名单过滤标签属性</li><li>输出口编码</li><li>CSP  保护前端网站</li><li>HttpOnly， 不让 js 获取 cookie</li><li>非标准。HTTP 响应中设置安全头部，如 X-XSS-Protection 和 X-Content-Type-Options</li></ol><h3 id="noreferer-noopener" tabindex="-1"><a class="header-anchor" href="#noreferer-noopener" aria-hidden="true">#</a> noreferer/noopener</h3><h4 id="noreferer" tabindex="-1"><a class="header-anchor" href="#noreferer" aria-hidden="true">#</a> noreferer</h4><p><code>&lt;a href=&quot;&quot; rel=&quot;noreferer&quot;&gt;link&lt;/a&gt;</code></p><p>一般跳转会携带 referer 头表明来源。noreferer 可以不携带，避免服务器根据 referer 返回钓鱼网页</p><h4 id="noopener" tabindex="-1"><a class="header-anchor" href="#noopener" aria-hidden="true">#</a> noopener</h4><p><code>&lt;a href=&quot;http://other.site&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LINK&lt;/a&gt;</code></p><p>配置了<code>_blank</code>会打开新的标签页，新标签页可以获取到原标签页的属性 <code>window.opener</code>，可以访问原标签页的 location。保护原标签页 url location 不被篡改，noopner 不对传递原标签页的文档对象。</p><h2 id="三方-cookie" tabindex="-1"><a class="header-anchor" href="#三方-cookie" aria-hidden="true">#</a> 三方 cookie</h2><h3 id="chips" tabindex="-1"><a class="header-anchor" href="#chips" aria-hidden="true">#</a> CHIPS</h3><p>具有独立分区状态的 Cookie (CHIPS) ，它允许开发者将 Cookie 选择到“分区”存储中，每个顶级站点都有单独的 Cookie jar。</p><p>在 A 站访问 C 站，C 站将会在 A 站种 cookie，禁用三方 cookie，C 将访问不到 cookie。</p><p>引入 Partitioned 概念，C 站在 A 站种的 cookie，C 只能在访问 A 站时访问到这个 cookie。</p><p><code>Set-Cookie: name=ConardLi; SameSite=None; Secure; Path=/; Partitioned;</code></p><p>C 在它的 Cookie 上指定了 Partitioned 属性，这个 Cookie 将保存在一个特殊的分区 jar 中。它只会在站点 A 中通过 iframe 嵌入站点 C 时才会生效，浏览器会判定只会在顶级站点为 A 时才发送该 Cookie。</p>',64),S={href:"/images/CHIPS-1.png",target:"_blank",rel:"noopener noreferrer"},C={href:"/images/CHIPS-2.png",target:"_blank",rel:"noopener noreferrer"},P=e("h3",{id:"first-party-sets-第一方集",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#first-party-sets-第一方集","aria-hidden":"true"},"#"),n(" First-Party Sets 第一方集")],-1),H=e("p",null,"douyin.com、bytedance.com 这两个域名虽然是属于同一个组织，但是 Chrome 不知道，你可以通过把它们放到一个集合里来告诉 Chrome 这些不同的域名属于同一个组织。",-1),E=e("ol",null,[e("li",null,"把想要共享 Cookie 的不同域名放到一个集合里，然后提交给 Chrome；"),e("li",null,"使用 Chrome 提供的特殊的方式来读取这些域名集合下共享的 Cookie；")],-1);function y(w,A){const a=r("ExternalLinkIcon");return o(),p("div",null,[b,e("ul",null,[f,_,e("li",null,[e("a",g,[n("http2"),s(a)]),n(" 用帧和流实现多路复用，多个 http 可以在一个 tcp 中进行")]),x]),T,e("p",null,[e("a",S,[n("CHIPS"),s(a)]),e("a",C,[n("CHIPS"),s(a)])]),P,H,E])}const L=i(k,[["render",y],["__file","网络.html.vue"]]);export{L as default};

import{_ as i,r as n,o as r,c as t,a as e,d as l,b as o,e as h}from"./app-7D7ZZLlA.js";const d={},s=e("h1",{id:"设计模式",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#设计模式","aria-hidden":"true"},"#"),l(" 设计模式")],-1),c=e("p",null,"可重用的面相对向的准则",-1),p=e("h2",{id:"单一职责原则",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#单一职责原则","aria-hidden":"true"},"#"),l(" 单一职责原则")],-1),_=e("p",null,"一个对象或方法只做一件事情， 每个模块专注于自己的职责",-1),u=e("p",null,"微服务",-1),f=e("li",null,[e("p",null,"单例模式 保证一个类只有一个模式"),e("p",null,"例子： 只 new 一次， 已经有实例就返回实例")],-1),x=e("li",null,[e("p",null,"代理模式"),e("p",null,"为其他对象提供一种代理以控制对这个对象的访问"),e("p",null,"例子： 返回一个方法可以修改 img 标签的 src")],-1),b=e("p",null,[l("迭代器模式 提供方法能"),e("strong",null,"顺序访问"),l("一个聚合对象中的各个元素， 又不需要暴露该对象内部表示")],-1),m={href:"/js/%E5%AF%B9%E8%B1%A1.html#for-of",target:"_blank",rel:"noopener noreferrer"},g=e("li",null,[e("p",null,"装饰者模式")],-1),k=h('<h2 id="最少知识原则-迪米特法则" tabindex="-1"><a class="header-anchor" href="#最少知识原则-迪米特法则" aria-hidden="true">#</a> 最少知识原则（迪米特法则）</h2><p>高内聚 低耦合</p><p>一个对象应当尽可能少的与其他对象发生相互作用</p><ul><li><p>中介者模式 定义一个对象（中介者）， 该对象封装了系统中对象间的交互方式</p><p>例子： 不同的事件监听用相同的回调函数</p></li><li><p>外观模式 不同的实现隐藏起来</p><p>jquery 的元素事件, <code>elem.on(&#39;event&#39;, callback)</code>, 封装了方法，内部兼容各种浏览器的实现</p></li></ul><h2 id="开放封闭原则" tabindex="-1"><a class="header-anchor" href="#开放封闭原则" aria-hidden="true">#</a> 开放封闭原则</h2><p>软件实体（类，模块，函数）都应该可以扩展， 而不应该修改</p><p>对扩展开放，对修改关闭</p><p>webpack loader</p><ul><li>发布订阅模式</li><li>模版方法模式</li><li>策略模式</li><li>代理模式</li><li>职责链模式</li></ul><h3 id="发布订阅-观察者" tabindex="-1"><a class="header-anchor" href="#发布订阅-观察者" aria-hidden="true">#</a> 发布订阅 观察者</h3><h4 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h4><p>每个观察者实现相同接口，供被观察者调用，两者松耦合</p><h4 id="发布订阅" tabindex="-1"><a class="header-anchor" href="#发布订阅" aria-hidden="true">#</a> 发布订阅</h4><p>在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。 需要 broker</p><p>两者完全解耦，多用于跨应用，比如消息中间件</p><h2 id="代码重构原则" tabindex="-1"><a class="header-anchor" href="#代码重构原则" aria-hidden="true">#</a> 代码重构原则</h2><p>重构必然会发生， 早晚的问题而已， 要尽量拖慢重构发生时间</p><ul><li>提炼函数 =&gt; 更易于单一原则</li><li>合并重复代码片段</li><li>条件分支语句提炼成函数 =&gt; 判断表达提取为函数</li><li>合理使用循环 =&gt; try catch 嵌套改为用循环实现一次 try</li><li>用提前 return 代替嵌套条件分支 =&gt; 用多个 if 代替 if else 多层嵌套</li><li>传递对象参数代理过长的参数列表 =&gt; 参数封装成 对象</li><li>尽量减少参数数量</li><li>合理使用链式调用</li></ul>',18);function E(B,v){const a=n("ExternalLinkIcon");return r(),t("div",null,[s,c,p,_,u,e("ul",null,[f,x,e("li",null,[b,e("p",null,[l("例子： 不需要考虑 forEach 内部如何实现 "),e("a",m,[l("给对象添加迭代器"),o(a)])])]),g]),k])}const V=i(d,[["render",E],["__file","设计模式.html.vue"]]);export{V as default};

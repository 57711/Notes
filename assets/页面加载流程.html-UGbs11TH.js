import{_ as l,o as i,c as e,e as r}from"./app-7D7ZZLlA.js";const a="/Notes/images/browser-url.png",t="/Notes/images/从文本解析html.png",s={},n=r('<h1 id="页面加载流程" tabindex="-1"><a class="header-anchor" href="#页面加载流程" aria-hidden="true">#</a> 页面加载流程</h1><h2 id="输入-url-发生什么-浏览器进程" tabindex="-1"><a class="header-anchor" href="#输入-url-发生什么-浏览器进程" aria-hidden="true">#</a> 输入 url 发生什么 /浏览器进程</h2><ul><li><p>DNS 寻址，如果直接用 ip 访问也会寻址</p></li><li><p>http 服务器将 html 以 response 返回给浏览器</p></li><li><p>网络进程中的线程获取 html， 生成渲染任务传递给渲染进城中的主线程， 根据 event loop， 渲染线程执行渲染任务</p></li></ul><p><strong>渲染主线程</strong></p><ul><li>html 解析 dom <ul><li>有预编译过程, 预解析线程, css，js 开始统一发出去</li><li>defer async</li><li>遇到 js 代码， 暂停 html， 解析 js 或等待 js 加载</li><li>遇到 css， 给到 css 线程，不阻塞 html 解析</li></ul></li><li>css 解析 <ul><li>css 解析和 html 解析互不干扰， 有单独线程</li><li>css 不会阻塞 html 解析</li><li>Css 会阻塞 dom 渲染， 因为无法构建 render 树</li></ul></li><li>样式计算 <ul><li>结合 DOM 和 CSSOM 树</li><li>css 开始属性计算，每个属性都有值， auto, px，%</li><li><strong>级联</strong> （判断优先级）</li><li><strong>继承</strong></li><li>生成带有样式的 dom 树， 更新 document.stylesheet</li><li>用 getComputedStyle 获取</li></ul></li><li>布局 layout <ul><li>生成布局树, render tree, 和 dom 树是不对应的</li><li>算每个节点的几何信息: <strong>尺寸，位置</strong></li><li>浮动规则</li><li>区块格式化上下文 <strong>BFC</strong> (Block formatting context)</li><li><strong>包含块</strong> containing block（参照物）</li><li>display:none 没有， :after 伪元素有， 匿名块盒/行盒 <ul><li>文本内容必须在行盒中</li><li>行盒和块盒不能相邻</li></ul></li></ul></li><li>分层 <ul><li>生成 RenderLayers 树， 考虑重绘</li><li>滚动条，<strong>堆叠上下文</strong>z-index, opacity, transform</li><li>css 属性 will-change: transform</li></ul></li><li>绘制 <ul><li>为每一层<strong>生成绘制的指令</strong></li><li>交给合成线程</li></ul></li></ul><p><strong>合成线程</strong></p><ul><li>分块 tiling <ul><li>将每一层分为多个小区域， 在 viewport 中的优先画</li><li>在合成线程中执行，合成线程还会启动多个工作线程来分块</li><li>将块信息给到 GPU 进程</li></ul></li></ul><p><strong>GPU 进程</strong></p><ul><li><strong>光栅化</strong><ul><li>多线程执行光栅化，优先 viewport 区域</li><li>生成位图， 交给合成线程</li></ul></li></ul><p><strong>合成线程</strong></p><ul><li>画 <ul><li>根据位图生成 quad 指引信息， 块相对于屏幕的位置</li><li>quad 交给 GPU 进程， 要进行系统调用，需要 GPU 进程帮助</li><li>transform 发生在这里，而不在渲染主线程上</li></ul></li></ul><p><strong>GPU 进程</strong></p><ul><li>GPU 渲染 <ul><li>利用 GPU</li></ul></li></ul><p><img src="'+a+'" alt="输入url 发生什么"></p><h3 id="reflow-重排" tabindex="-1"><a class="header-anchor" href="#reflow-重排" aria-hidden="true">#</a> Reflow 重排</h3><p>需要重新生成 render tree</p><p>例如更新了 dom， 或者更新了 CSS 的几何信息 CSSOM</p><p>js 配置样式，产生异步 reflow ， 会合并所有 js 动作，放到 eventloop 中等待更新</p><p>js 读取样式，会产生同步 reflow， 立即拿到当前样式</p><p>设置不会立刻导致 reflow， 但是读取会</p><h3 id="repaint-重绘-发生在-style" tabindex="-1"><a class="header-anchor" href="#repaint-重绘-发生在-style" aria-hidden="true">#</a> Repaint 重绘（发生在 style）</h3><p>需要重新计算绘制指令集， 跳过 layout，layer 步骤</p><p>可见样式更改（发生在 style）会引发 repaint</p><h3 id="transform-效率高" tabindex="-1"><a class="header-anchor" href="#transform-效率高" aria-hidden="true">#</a> transform 效率高</h3><p>只在最后 draw 的步骤</p><p>js 修改 transform， cssom 树会变， 会影响 style</p><p>animation 属性修改 transform， 只影响最后 draw, 在合成线程中，不会被 js 阻塞</p><p>滚动条滚动也在 draw, 合成线程</p><h3 id="从文本解析-html" tabindex="-1"><a class="header-anchor" href="#从文本解析-html" aria-hidden="true">#</a> 从文本解析 html</h3><p><img src="'+t+'" alt="从文本解析html"></p><h2 id="事件" tabindex="-1"><a class="header-anchor" href="#事件" aria-hidden="true">#</a> 事件</h2><p><strong>DOMContentLoad 事件</strong> 在同步 js 解析完触发, dom load 完成</p><p><strong>load 事件</strong> css js 等资源全部 load 完， 一般更迟出发</p><p><strong>domInteractive</strong> 开始显示页面 FID</p><h3 id="渲染过程" tabindex="-1"><a class="header-anchor" href="#渲染过程" aria-hidden="true">#</a> 渲染过程</h3><ol><li>根据 html 创建 renderLayer 树 z-index， float， position</li><li>栅格化， 绘制位图， 利用 gpu 进程绘制</li><li>如利用 gpu， 有 GraphicsLayer</li><li>第一次绘制， first paint 事件， 只绘制可视区域， 不必等待整个 html 解析完， first paint 和 DOMContentLoad 无关</li><li>所有加载项完毕出发 onload</li></ol><h2 id="几种-tree" tabindex="-1"><a class="header-anchor" href="#几种-tree" aria-hidden="true">#</a> 几种 tree</h2><h3 id="dom-tree" tabindex="-1"><a class="header-anchor" href="#dom-tree" aria-hidden="true">#</a> dom tree</h3><h3 id="renderobject-tree" tabindex="-1"><a class="header-anchor" href="#renderobject-tree" aria-hidden="true">#</a> renderObject tree</h3><ul><li>不包含不可见元素</li><li>其上 layout 方法可计算布局信息</li><li>某些情况下需要建立匿名的 RenderObject 节点；</li></ul><h3 id="renderlayers-tree" tabindex="-1"><a class="header-anchor" href="#renderlayers-tree" aria-hidden="true">#</a> RenderLayers Tree</h3><ul><li>根节点</li><li>css position / transform</li><li>overflow / opacity</li><li>canvas</li><li>video</li></ul><h3 id="graphicslayers-compositelayer-对-renderlayer-提供后端存储" tabindex="-1"><a class="header-anchor" href="#graphicslayers-compositelayer-对-renderlayer-提供后端存储" aria-hidden="true">#</a> GraphicsLayers / compositeLayer 对 RenderLayer 提供后端存储</h3><ul><li>RenderLayer 具有 CSS 3D 属性或者 CSS 透视效果。</li><li>RenderLayer 包含的 RenderObject 节点表示的是使用硬件加速的视频解码技术的 HTML5 video 元素。</li><li>RenderLayer 包含的 RenderObject 节点表示的是使用硬件加速的 Canvas2D 元素或者 WebGL 技术。</li><li>RenderLayer 使用了 CSS 透明效果的动画或者 CSS 变换的动画。</li><li>RenderLayer 使用了硬件加速的 CSSfilters 技术。</li><li>RenderLayer 的后代中包括了一个合成层。</li><li>合成层上面(z 轴上距离读者更近)的 RenderLayer 也是一个合成层</li></ul><h2 id="进程线程" tabindex="-1"><a class="header-anchor" href="#进程线程" aria-hidden="true">#</a> 进程线程</h2><p>一般至少 4 个进程：</p><ul><li><p>主进程/浏览器进程</p></li><li><p>网络进程</p></li><li><p>Gpu 进程</p></li><li><p>渲染进程 / 一个标签页一个渲染进程 拥有多个线程 渲染主线程</p><ul><li><p>Blink / v8, 每个 tab 一个渲染进程， 运行在沙箱中</p></li><li><p>GUI 渲染线程 =&gt; 解析 html/css，DOM/CSSOM，重绘重排，与 js 引擎互斥</p></li><li><p>JS 引擎线程 =&gt; 一个 tab 一个 js 引擎</p></li><li><p>时间触发线程 =&gt; event loop， 将任务添加到队列中</p></li><li><p>定时器触发线程 =&gt; setTimeout/setInterval 用来计数，计时完毕添加到事件队列</p></li><li><p>异步 http 请求线程 =&gt; 将回调放入事件队列</p></li><li><p>合成线程</p></li></ul></li><li><p>插件进程 沙箱</p></li></ul><p>Ignition 编译成字节码， 并收集信息优化，扔给 turbofan 编译成机器码，机器码可以 deoptimize 成字节码</p>',48),o=[n];function d(p,h){return i(),e("div",null,o)}const u=l(s,[["render",d],["__file","页面加载流程.html.vue"]]);export{u as default};

import{_ as i,r as l,o as d,c as r,a as e,d as a,b as s,e as t}from"./app-7D7ZZLlA.js";const c={},o=t(`<h1 id="项目" tabindex="-1"><a class="header-anchor" href="#项目" aria-hidden="true">#</a> 项目</h1><h2 id="项目本质" tabindex="-1"><a class="header-anchor" href="#项目本质" aria-hidden="true">#</a> 项目本质</h2><ul><li>管理数据 -&gt; 管理变量 <ul><li>DB：存储数据</li><li>Backend： 数据的增删改查，组织</li><li>frontend：runtime 中管理变量的生命周期[modal]，展示数据[view]</li></ul></li></ul><h2 id="亮点" tabindex="-1"><a class="header-anchor" href="#亮点" aria-hidden="true">#</a> 亮点</h2><ul><li>基于业务，封装公共能力，解决业务中的标准问题，并<strong>派生推广</strong><ul><li>相似的逻辑抽象，推广后能提效，派生推广提效是重点</li><li>插件，埋点</li></ul></li><li>使用工程化手段，解决开发逻辑或一类流程性标准的问题。 <ul><li>规范化工作流程，或者逻辑流程</li><li>架构的设计，sdk 分层，隔离，工程架构</li></ul></li><li>行业之前没有的东西。</li></ul><h2 id="monorepo" tabindex="-1"><a class="header-anchor" href="#monorepo" aria-hidden="true">#</a> monorepo</h2><p>开发策略，多个项目用一个代码仓库来<strong>管理依赖关系</strong>。项目间有复用的，可以抽象</p><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h3><p>优点：</p><ul><li>降低基础设施成本，构建，测试，部署逻辑统一。</li><li>本地的依赖永远是最新的</li><li>跨多个项目的 issue 更容易管理</li><li>node_modules 可以复用，加速开发</li></ul><p>缺点：</p><ul><li>仓库大</li><li>版本管理复杂，需要更新解决不兼容问题</li><li>仓库不能精细管理，不安全。</li></ul><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h3><h4 id="lerna" tabindex="-1"><a class="header-anchor" href="#lerna" aria-hidden="true">#</a> lerna</h4><ul><li>适合做版本管理 independent 模式</li><li>没有库之间的软连接</li></ul><h5 id="independent-模式" tabindex="-1"><a class="header-anchor" href="#independent-模式" aria-hidden="true">#</a> Independent 模式</h5><p>配合 Git，检查文件变动，只发布有改动的包。</p><h5 id="fixed-locked-模式" tabindex="-1"><a class="header-anchor" href="#fixed-locked-模式" aria-hidden="true">#</a> Fixed/Locked 模式</h5><p>整个项目全量发布，所有包共用一个版本号。lerna 默认模式</p><h4 id="pnppm-yarn" tabindex="-1"><a class="header-anchor" href="#pnppm-yarn" aria-hidden="true">#</a> pnppm/yarn</h4><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">packages</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token string">&#39;packages/**&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>全局,根目录 <code>pnpm add lodash -w</code></li><li>添加到具体项目 <code>pnpm add lodash --filter &lt;package-name&gt;</code></li><li>安装内部包 <code>pnpm add &lt;my-package&gt; --filter &lt;package-name&gt;</code><ul><li>类似于<code>npm link</code></li></ul></li></ul><h2 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h2><ul><li>eslint <ul><li><code>eslint --init</code>，会提示安装以下 3 个包</li><li><code>@typescript-eslint/eslint-plugin@latest</code></li><li><code>eslint-plugin-react@latest</code></li><li><code>@typescript-eslint/parser@latest</code></li></ul></li><li>prettier <ul><li>配置<code>.prettierrc.json</code>, 配合 vscode 插件</li></ul></li></ul><h2 id="ts" tabindex="-1"><a class="header-anchor" href="#ts" aria-hidden="true">#</a> ts</h2><p>两种方案，一般不直接用 tsc 编译，只用作检查。</p><ol><li><code>@babel/preset-typescript</code>编译 + tsc 类型检查</li><li>webpack 上用<code>ts-loader</code>编译 + tsc 类型检查</li></ol><p><code>tsc --init</code> 创建 tsconfig.json</p><h2 id="webpack-相关" tabindex="-1"><a class="header-anchor" href="#webpack-相关" aria-hidden="true">#</a> webpack 相关</h2><p>webpack react 相关 loader，plugins</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">pnpm</span> <span class="token function">add</span> webpack webpack-cli webpack-dev-server webpack-merge

@babel/core @babel/preset-react @babel/reset-env @babel/preset-typescript babel-loader

css-loader style-loader

<span class="token function">less</span> less-loader postcss postcss-loader tailwindcss autoprefixer

html-webpack-plugin css-minimizer-plugin mini-css-extract-plugin terser-webpack-plugin

cross-env
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> react</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">pnpm</span> <span class="token function">add</span> react react-dom @types/react @types/react-dom
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="前端构建" tabindex="-1"><a class="header-anchor" href="#前端构建" aria-hidden="true">#</a> 前端构建</h2><h3 id="boundled" tabindex="-1"><a class="header-anchor" href="#boundled" aria-hidden="true">#</a> boundled</h3><p>打包成一个 js，webpack，前端工程会用到，本地开发环境也需要构建</p><ul><li>HTTP/1.1 各浏览器有并行连接限制</li><li>浏览器不支持模块系统（如 CommonJS 包不能直接在浏览器运行）</li><li>代码依赖关系与顺序管理</li></ul><h3 id="boundleless-noboundle" tabindex="-1"><a class="header-anchor" href="#boundleless-noboundle" aria-hidden="true">#</a> boundleless / noboundle</h3><p>保持原本的模块方案，rollup + 多入口，适合组件库</p><ul><li>HTTP/2.0 多路并用</li><li>各大浏览器逐一支持 ESM</li><li>越来越多的 npm 包拥抱 ESM（尽管很多包的依赖并不是）</li></ul><h2 id="css-隔离方案" tabindex="-1"><a class="header-anchor" href="#css-隔离方案" aria-hidden="true">#</a> css 隔离方案</h2><h3 id="css-in-js" tabindex="-1"><a class="header-anchor" href="#css-in-js" aria-hidden="true">#</a> css in js</h3><p>css 写成字符串放到组件内，emotion, styled-component</p><h3 id="css-module" tabindex="-1"><a class="header-anchor" href="#css-module" aria-hidden="true">#</a> css module</h3><ul><li>局部作用域，class 名唯一，bem 规范（<code>block-element__modified</code>），vue 中的 scoped css</li><li>模块依赖， compose</li></ul><p>配置 css-loader</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 开启局部作用域</span>
<span class="token comment">// 定制类的哈希字符串的格式</span>
<span class="token punctuation">{</span>
  <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
  <span class="token literal-property property">loader</span><span class="token operator">:</span> <span class="token string">&quot;style-loader!css-loader?modules&amp;localIdentName=[path][name]---[local]---[hash:base64:5]&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="utility-css" tabindex="-1"><a class="header-anchor" href="#utility-css" aria-hidden="true">#</a> utility css</h3><p>tailwindcss, 原子化</p><p><code>npx tailwindcss init</code></p><h3 id="shadowdom" tabindex="-1"><a class="header-anchor" href="#shadowdom" aria-hidden="true">#</a> shadowdom</h3><h2 id="组件方案" tabindex="-1"><a class="header-anchor" href="#组件方案" aria-hidden="true">#</a> 组件方案</h2><p>自建/三方？</p><p>如果 ui 自己写，headless + tailwindcss + css 模块</p><h2 id="微前端方案" tabindex="-1"><a class="header-anchor" href="#微前端方案" aria-hidden="true">#</a> 微前端方案</h2><ul><li>iframe，容易实现</li><li>module federation</li><li>web components</li><li>code split 直接代码分割</li><li>single-spa qiankun microapp</li><li>npm 打成独立包</li></ul><h3 id="js-隔离" tabindex="-1"><a class="header-anchor" href="#js-隔离" aria-hidden="true">#</a> js 隔离</h3><p>消除微应用对全局变量，全局事件的影响。局部 js 对外部访问修改可控</p><p>实现沙箱：</p><ul><li>with， window.proxy， Map</li><li>快照，多实例，单实例</li></ul><h2 id="消息推送" tabindex="-1"><a class="header-anchor" href="#消息推送" aria-hidden="true">#</a> 消息推送</h2><p>分类：</p>`,62),p=e("li",null,[a("客户端拉取 "),e("ul",null,[e("li",null,"长轮询"),e("li",null,"短轮询")])],-1),h={href:"/frontend/%E7%BD%91%E7%BB%9C.html#websocket",target:"_blank",rel:"noopener noreferrer"},u={href:"/frontend/%E7%BD%91%E7%BB%9C.html#sse-server-sent-events",target:"_blank",rel:"noopener noreferrer"},b=e("h2",{id:"特色项目",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#特色项目","aria-hidden":"true"},"#"),a(" 特色项目")],-1),m=e("ul",null,[e("li",null,"ai 交互"),e("li",null,"实时性，webRTC，websocket"),e("li",null,"低代码，（工具类）")],-1);function v(k,f){const n=l("ExternalLinkIcon");return d(),r("div",null,[o,e("ul",null,[p,e("li",null,[a("服务端推送 "),e("ul",null,[e("li",null,[e("a",h,[a("websocket"),s(n)])]),e("li",null,[e("a",u,[a("sse（server-sent events）"),s(n)])])])])]),b,m])}const x=i(c,[["render",v],["__file","项目.html.vue"]]);export{x as default};

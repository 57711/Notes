# 为什么选择函数组件

## 类和函数组件

React 中的类通常被称为“类组件”。它们传统上用于定义组件并管理其状态和生命周期。类组件扩展了 React.Component 类，并且需要更多样板代码。

函数组件是定义 React 组件的一种更简洁、更现代的方式。它们也被称为“功能组件”。函数组件本质上是返回 JSX 元素的 JavaScript 函数。

## 函数组件优势

- 代码少，使用函数式编程，没有`this`
- hooks性能好，简化生命周期
- 使用闭包，变量是当前函数内部的

先点button，再修改props

```js
function ComFn(props) {
    console.log("函数式组件的函数被调用了");

    //这个是闭包：
    // 每调用一次父函数（ComFn），都会重新定义一个新的子函数。新的函数中保存着父函数新的形参
    const showMessage = () => {
        console.log('函数式组件: ' + props.name);
    };

    //这个是闭包：
    //每调用一次父函数（ComFn），都会重新定义一个新的子函数。新的函数中保存着父函数新的形参
    const handleClick = () => {
        setTimeout(showMessage, 3000);
    };
    
    return (
        <div style={{ "backgroundColor": "skyblue" }}>
            <h5 >我是函数式组件</h5>
            <p>name：{props.name}</p>
            {/*先点击这个按钮，调用，第一次定义的 showMessage和handleClick*/}
            <input type="button" value="调用带着定时器的函数" onClick={handleClick} />
        </div>
    );
}
```

## 函数组件问题

- 使用闭包，有陷阱

## 总结

**界面应当是数据的不同形式的简单投影。相同的输入应该产生相同的输出。**

- 而函数式组件的写法，使用闭包的特性，显然符合这一理念：每个闭包里保存在父函数的当前形参（props）和局部变量。

    函数组件主要是函数式编程，无副作用，并且在引用的时候透明的特点

- 而类组件里，由于，每次读取数据，要根据this指针去读取，那必然不会读取到属于自己当前状态的值。而是更新后的最新的值。

    类的组件主要是面向对象编程，是建立在继承之上，它的生命周期等核心概念的特点

## 生命周期

- UNSAFE_componentWillMount, 在异步渲染下容易重复调用, 函数组件没有
- componentDidMount, useEffect
- render，类组件render方法不能有副作用和setState。
- UNSAFE_componentWillReceiveProps, 组件更新之前处理逻辑
- shouldComponentUpdate，返回true 表示需要更新， 可做性能优化。类似函数组件useMemo， useCallback
- UNSAFE_componentWillUpdate， 组件重新渲染之前。异步渲染模式下，dom元素状态会不一致，对dom操作不安全
- getSnapshotBeforeUpdate, 更新dom之前调用，比如记录更新前的scrolltop，返回值传递给`  componentDidUpdate`
- componentDidUpdate， 组件因 props 或状态更改而重新渲染后调用, 可以操作dom
- componentWillUnmount， 函数组件中用useEffect
- componentDidCatch, 捕获错误，配合static getDerivedStateFromError， 在渲染子组件的过程中，页面更新之前

有副作用时或与外部同步，需要同时实现`componentDidMount, componentDidUpdate, componentWillUnmount`.

函数组件中用useEffect替代

![react15函数组件生命周期](/images/react_lifecycle.png)

react 16 去除`UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, UNSAFE_componentWillUpdate`。不安全的原因，render阶段改为异步的渲染，可以被暂停重启，会导致这几个生命周期重复调用。

`getDerivedStateFromProps` 用static修饰，不允许使用this。不允许比较`this.props`, 而是`nextProps`与`prevState`中的值
![react16生命周期](/images/react16_lifecycle.png)

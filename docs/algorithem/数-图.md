---
title: 数&图
date: 2023-12-16T11:14:50.583Z
---
# Tree & Graph

[[toc]]

## 二叉树/二叉搜索树

元素排列有序，查找块，每次查找一半$O(logN)$

### 题目

-  [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

**方案1**： 中序遍历in-order, 左 + 中 + 右，得到Array，需要时是升序的，同排序后结果比较。 每个节点只遍历一次，$O(N)$， 比较占空间，每次递归数组需要存储

**方案2**： 中序遍历， 但是不保存所有数组， 只记录前继节点， 当前子节点树与前继父节点比较

prev 节点的变化

![inorder](/images/inorder.png "inorder")

```js
var isValidBST = function(root) {
    let prev = null
    function inOrder (root){
        if(!root) return true
        if(!inOrder(root.left)) return false
        if(prev && root.val <= prev.val) return false
        // 当前节点需要比上次一节点大
        prev = root
        return inOrder(root.right)
    }
    return inOrder(root)
};
```

**方案3**： 递归， 每次递归得到左子树最大值$max_left$， 右子树最小值$min_right$, 要求$max_left < root < min_right$. 每个节点只遍历一次，$O(N)$

```js
function isValid(root, floor, ceil) {
    if (root === null) return true;
    if (root.val <= floor || root.val >= ceil) return false;
    return isValid(root.left, floor, root.val) && isValid(root.right, root.val, ceil);
}
isValid(root, -Infinity, Infinity)
```

- [最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

**任意二叉树**

当前节点没有返回null， 当前节点等于p或q返回当前节点。 左节点为空返回右节点， 右节点为空返回左节点，都不为空返回当前节点 $O(N)$

**二叉搜索树**

可以通过值来判断左右子树， 如果root大于pq， 都在左子树， root小于pq， 都在右子树，否则就直接是root






## 图
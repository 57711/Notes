---
title: 数&图
date: 2023-12-16T11:14:50.583Z
---
# Tree & Graph

\[[toc]]

## 二叉树/二叉搜索树

元素排列有序，查找块，每次查找一半$O(logN)$

### 题目

* [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

**方案1**： 中序遍历in-order, 左 + 中 + 右，得到Array，需要时是升序的，同排序后结果比较。 每个节点只遍历一次，$O(N)$， 比较占空间，每次递归数组需要存储

**方案2**： 中序遍历， 但是不保存所有数组， 只记录前继节点， 当前子节点树与前继父节点比较

![inorder](/images/inorder.png "inorder")

```js
var isValidBST = function(root) {
    let prev = null
    function inOrder (root){
        if(!root) return true
        if(!inOrder(root.left)) return false
        if(prev && root.val <= prev.val) return false
        // 当前节点需要比上次一节点大
        prev = root
        return inOrder(root.right)
    }
    return inOrder(root)
};
```

**方案3**： 递归， 每次递归得到左子树最大值$max_left$， 右子树最小值$min_right$, 要求$max_left < root < min_right$. 每个节点只遍历一次，$O(N)$

```js
function isValid(root, floor, ceil) {
    if (root === null) return true;
    if (root.val <= floor || root.val >= ceil) return false;
    return isValid(root.left, floor, root.val) && isValid(root.right, root.val, ceil);
}
isValid(root, -Infinity, Infinity)
```

## 图
# 设计模式

可重用的面相对向的准则

## 单一职责原则

一个对象或方法只做一件事情， 每个模块专注于自己的职责

微服务

- 单例模式
  保证一个类只有一个模式

  例子： 只 new 一次， 已经有实例就返回实例

- 代理模式

  为其他对象提供一种代理以控制对这个对象的访问

  例子： 返回一个方法可以修改 img 标签的 src

- 迭代器模式
  提供方法能**顺序访问**一个聚合对象中的各个元素， 又不需要暴露该对象内部表示

  例子： 不需要考虑 forEach 内部如何实现
  [给对象添加迭代器](/js/对象.html#for-of)

- 装饰者模式

## 最少知识原则（迪米特法则）

高内聚 低耦合

一个对象应当尽可能少的与其他对象发生相互作用

- 中介者模式
  定义一个对象（中介者）， 该对象封装了系统中对象间的交互方式

  例子： 不同的事件监听用相同的回调函数

- 外观模式
  不同的实现隐藏起来

  jquery 的元素事件, `elem.on('event', callback)`, 封装了方法，内部兼容各种浏览器的实现

## 开放封闭原则

软件实体（类，模块，函数）都应该可以扩展， 而不应该修改

对扩展开放，对修改关闭

webpack loader

- 发布订阅模式
- 模版方法模式
- 策略模式
- 代理模式
- 职责链模式
- 工厂模式

### 发布订阅 观察者

#### 观察者模式

每个观察者实现相同接口，供被观察者调用，两者松耦合

#### 发布订阅

在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。 需要 broker

两者完全解耦，多用于跨应用，比如消息中间件

### 工厂模式

创建复杂对象可以用工厂模式，一个产品一个工厂类，灵活，但是类越来越多。

用于记录日志或数据到不同地方，例如数据库，本地硬盘，远程服务等。

#### 简单工厂模式 Simple Factory Pattern

- 工厂类：根据参数返回不同对象
- 抽象产品类：是所有对象的父类，描述所有实例的公共接口
- 具体产品类：每一个具体产品继承抽象产品，实现抽象产品的抽象方法

```ts
interface Fruit {} // 抽象产品
class Apple implements Fruit {} // 具体产品
class Orange implements Fruit {}
class FruitFactory {
  // 工厂
  createFruit(type) {
    switch (type) {
      case 'apple':
        return new Apple();
      case 'orange':
        return new Orange();
    }
  }
}
new FruitFactory().createFruit('apple');
```

#### 工厂方法模式 Factory Pattern

- 抽象工厂： 描述具体工厂的公共接口，具体工厂的父类
- 具体工厂：实现抽象工厂的方法，创建产品实例，供外接调用
- 抽象产品：所有具体产品的公共接口
- 具体产品：具体实例，实现抽象产品的方法，由具体工厂来创建

## 代码重构原则

重构必然会发生， 早晚的问题而已， 要尽量拖慢重构发生时间

- 提炼函数 => 更易于单一原则
- 合并重复代码片段
- 条件分支语句提炼成函数 => 判断表达提取为函数
- 合理使用循环 => try catch 嵌套改为用循环实现一次 try
- 用提前 return 代替嵌套条件分支 => 用多个 if 代替 if else 多层嵌套
- 传递对象参数代理过长的参数列表 => 参数封装成 对象
- 尽量减少参数数量
- 合理使用链式调用

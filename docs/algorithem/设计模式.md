# 设计模式

可重用的面相对向的准则

## 单一职责原则

一个对象或方法只做一件事情， 每个模块专注于自己的职责

微服务

- 单例模式
  保证一个类只有一个模式

  例子： 只 new 一次， 已经有实例就返回实例

- 代理模式

  为其他对象提供一种代理以控制对这个对象的访问

  例子： 返回一个方法可以修改 img 标签的 src

- 迭代器模式
  提供方法能**顺序访问**一个聚合对象中的各个元素， 又不需要暴露该对象内部表示

  例子： 不需要考虑 forEach 内部如何实现
  [给对象添加迭代器](/js/对象.html#for-of)

- 装饰者模式

## 最少知识原则（迪米特法则）

高内聚 低耦合

一个对象应当尽可能少的与其他对象发生相互作用

- 中介者模式
  定义一个对象（中介者）， 该对象封装了系统中对象间的交互方式

  例子： 不同的事件监听用相同的回调函数

- 外观模式
  不同的实现隐藏起来

  jquery 的元素事件, `elem.on('event', callback)`, 封装了方法，内部兼容各种浏览器的实现

## 开放封闭原则

软件实体（类，模块，函数）都应该可以扩展， 而不应该修改

对扩展开放，对修改关闭

webpack loader

- 发布订阅模式
- 模版方法模式
- 策略模式
- 代理模式
- 职责链模式

### 发布订阅 观察者

#### 观察者模式

每个观察者实现相同接口，供被观察者调用，两者松耦合

#### 发布订阅

在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。 需要 broker

两者完全解耦，多用于跨应用，比如消息中间件

## 代码重构原则

重构必然会发生， 早晚的问题而已， 要尽量拖慢重构发生时间

- 提炼函数 => 更易于单一原则
- 合并重复代码片段
- 条件分支语句提炼成函数 => 判断表达提取为函数
- 合理使用循环 => try catch 嵌套改为用循环实现一次 try
- 用提前 return 代替嵌套条件分支 => 用多个 if 代替 if else 多层嵌套
- 传递对象参数代理过长的参数列表 => 参数封装成 对象
- 尽量减少参数数量
- 合理使用链式调用
